% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/99_InferTrajectories.R
\name{InferTrajectories}
\alias{InferTrajectories}
\title{Trajectory inference in single-cell expression data}
\usage{
InferTrajectories(
  expression = NULL,
  fcs_path = NULL,
  marker_names = NULL,
  fcs_rows = NULL,
  labels_per_event,
  origin_label,
  analysis_name = "tviblindi TI analysis",
  n_neighbours_knn = 100,
  n_neighbours_denoise = 30,
  n_iter_denoise = 1,
  somgrid_width = 25,
  somgrid_height = 25,
  transition_model_kernel = "Exp",
  n_neighbours_transition_model = 30,
  layout_method = "umap",
  n_walks = 5000,
  verbose = TRUE
)
}
\arguments{
\item{expression}{optional numeric matrix: coordinate matrix of expression data. Rows correspond to cells, columns correspond to markers. Columns must be named. Default value is \code{NULL}}

\item{fcs_path}{optional string: path to FCS file which contains the expression data. If \code{expression} is left as \code{NULL}, the expression matrix is extracted from this file. Default value is \code{NULL}}

\item{marker_names}{optional string vector: alternative expression matrix column names to the ones extracted from FCS file. Default value is \code{NULL}}

\item{fcs_rows}{optional integer vector: indices of expression matrix rows of FCS file that were taken (if \code{expression} is specified) or that should be taken (if \code{expression} is left as \code{NULL}). Default value is \code{NULL} (no subsetting)}

\item{labels_per_event}{string or factor vector: vector of population labels per each event (row of expression matrix)}

\item{origin_label}{string or integer: name population of origin or index of cell-of-origin}

\item{analysis_name}{string: name of \code{tviblindi} analysis. Default value is '\emph{tviblindi TI analysis}'}

\item{n_neighbours_knn}{integer: \code{k} parameter for building \code{k}-NN graph. Default value is \code{100}}

\item{n_neighbours_denoise}{integer: number of nearest neighbours for each point to use for data denoising (if denoising is used). Maximum \code{n_neighbours_knn}. Default value is \code{30}}

\item{n_iter_denoise}{integer: number of denoising iterations. Set to \code{0} to disable denoising. Default value is \code{1}}

\item{somgrid_width}{integer: height of SOM grid for \code{FlowSOM} clustering of expression data. Default value is \code{25}}

\item{transition_model_kernel}{string: name of kernel function to use for computing transition probabilities between cells.
One of \code{Exp} (exponential), \code{SE} (standard error), \code{Lap} (Laplacian). Default value is \code{Exp}}

\item{n_neighbours_transition_model}{integer: integer: number of nearest neighbours for each point to use for transition model building. Maximum \code{n_neighbours_knn}. Default value is \code{30}}

\item{layout_method}{string: name of dimension-reduction method for producing a 2-dimensional layout. One of \code{vaevictis}, \code{umap} and \code{tsne}. \code{vaevictis} is recommended, but it requires the \code{vaevictis} Python package and \code{reticulate} to be installed prior to calling \code{InferTrajectories}. Default value is \code{umap}}

\item{n_walks}{integer: number of random walks to simulate. Default value is \code{5000}}
}
\description{
This function uses the \code{tviblindi} trajectory-inference pipeline to discover tentative developmental pathways in biological expression data (cytometry, scRNA-seq, CITE-seq ADT).
It returns an object of class \code{tviblindi}, containing the ordering of cells along a pseudotime and simulated random walks through the dataset.
To categorise walks by terminal nodes and classify them by differences in direction, use the function \code{Interactive} to launch an interactive session in your web browser.
This will allow you to look how different markers are expressed at each pseudotemporal segment and to export pathways of interest.
}
\details{
\subsection{Input data and annotations}{

Input data are be provided in the form of a coordinate matrix.
You can either pass this matrix to \code{InferTrajectories} directly or, when working with cytometry data, you can give the path to an FCS file (and, optionally, row indices of events you want to use).

Other arguments to the \code{InferTrajectories} function include a vector of manually assigned population labels per cell and the label corresponding to the earliest progenitor cell population.
This is the population in which simulated developmental pathways always begin.
}

\subsection{Model parameters}{

Furthermore, the list of parameters uncludes the neighbour count for a \code{k}-nearest-neighbours graph construction, number of denoising iterations to eliminate technical noise, size of SOM grid for clustering, parameters of a transition model, method to use for computing a 2-dimensional layout of the data and number of random walks to simulate.
For ease of use, these parameters have default values that give good results for some mass cytometry datasets.

To understand each of the constituent steps, set parameters more carefully and use multiple label vectors, transition models and 2-dimensional layouts, use the following functions to run each step separately:
\itemize{
\item \code{tviblindi} for specifying input data and manually assigned labels,
\item \code{SetOrigin} for specofying a population of origin,
\item \code{Downsample} for downsampling your data if needed (better not to downsample whenever possible),
\item \code{ConstructkNNG} for constructing a \code{k}-nearest-neighbours graps,
\item \code{Denoise} for reducing technical variability in input data,
\item \code{AddLayout} for reducing dimensionality of input data and producing a 2-dimensional visualisation,
\item \code{Plot} for checking quality of the 2-dimensional layout,
\item \code{Cluster} for creating a self-organising map (SOM) of data using \code{FlowSOM} prior to filtration,
\item \code{Filter} for computing a witness-complex filtration of the high-dimensional data,
\item \code{ComputePseudotime} for modelling transition probabilities between cells and computing pseudotime for each cell,
\item \code{SimulateRandomWalks} for simulating stochastic walks governed by the transition model and pseudotemporal ordering,
}
}

\subsection{Connectome analysis}{

In addition to a classical trajectory-inference analysis, you can let \code{tviblindi} cluster the expresion data using the Louvain method for community detection and then estimate flux in the network.
Use the function \code{Connectome} to do this.
}
}
