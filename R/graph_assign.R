#' Assign labels to unlabelled events
#'
#' \code{assign_label} takes a transition matrix of a graph and a vector of labels (eg. cluster memberships) for each vertex in the graph. The function replaces labels \code{0} (which represents an unlabelled vertex)
#' with non-zero values found in the vector of labels. Label values are propagated via transitioning from labelled to unlabelled events, in accordance to transition probabilities
#' specified by the transition matrix. For instance, if labels are cluster memberships and some vertices do not belong in any cluster (label is \code{0}), clusters are 'grown' to include all vertices.
#'
#' The function involves solving as many systems of linear equations as there are unique label values.
#'  If dimension of transition matrix without labelled vertices exceeds a set threshold \code{big}, we solve the system numerically via conjugate gradient
#'  method for symmetric matrix or biconjugate gradient stabilised method for non-symmetric matrix.
#'  If we solve numerically, we set a maximum number of iterations (\code{nb_it}). Moreover, for numerical solutions error tolerance can be set manually (\code{eps}).
#'
#' Final label assigned to a vertex is determined by majority vote: the label which gets propagated most often, according to a diffusion process following the input transition matrix,
#'  is assigned to the given vertex.
#'
#' @param A transition matrix, as generated by \code{knn.spadj2sym}.
#' @param labels a numeric vector of labels. Length of \code{labels} is equal to the dimension of \code{A}.
#' @param big maximum number of non-origin vertices for exact solution of linear system. Defaults to \code{1000}.
#' @param nb_it maximum number of iterations for conjugate gradient or biconjugate gradient stabilised method. Defaults to \code{1500}.
#' @param eps error tolerance for conjugate gradient or biconjugate gradient stabilised method. Defaults to \code{1E-6}.
#'
#' @return
#' \code{assign_label} returns a list containing the following elements.
#'
#' \code{class} is a vector of vertex labels.
#'
#' \code{res} is a matrix generated via concatenation of column vectors which are solutions of
#'  N system of linear equations. Here, N is the number of unique labels. Each row corresponds to an unlabelled vertex and each column corresponds to a unique vertex label. Entries of the matrix are calculated via the
#'  propagation of labels in a diffusion process. The higher the value, the higher the likelihood that the given label is assigned to the given unlabelled vertex in this process. Indeed, the \code{class} vector of labels
#'  is generated by finding the column of maximum value of entry per row.
#'
#'  \code{error} values are relevant to numerical solution; error values are given for each of the N systems solved and stored in a vector. If solution
#'  is exact, \code{error} is an atomic \code{-1}.
#'
#'  \code{iteration} is relevant to numerical solution; it is a vector containing numbers of iterations needed for solution of each system. If solution is exact, \code{iteration}
#'  is an atomic \code{-1}.
#'
#' @export
assign_label<-function(A, labels, big = 1000, nb_it=1500,eps=1E-6) {
  ##A<-Matrix::t(A) ## think so... not tested for directed graphs
  D <- Matrix::Diagonal(x=Matrix::rowSums(A))
  L <- D - A

  labeled <- which(labels != 0)
  unlabeled <- which(labels == 0)

  Lu <- L[unlabeled,unlabeled]

  BT <- L[unlabeled,labeled]

  #build Q matrix
  K<-sort(unique(labels[labeled]))
  Q <- matrix(0, length(labeled), length(K))
  for (i in 1:length(K)) Q[labels[labeled]==K[i],i]<-1

  B <- -BT %*% Q
  if (length(unlabeled) > big) {
    res <- NULL
    error<-NULL
    iteration <- NULL
    print("iterative")
    for (k in 1:ncol(B)) {
      ress <- bicgSparse(Lu, as.vector(B[, k]),nb_it,eps)
      error<-c(error,ress$error)
      res<-cbind(res,ress$x)
      iteration <- c(iteration,ress$nb_it)
    }
  }

  else {
    res <- solve(Lu, B)
    error <- -1
    iteration <- -1
  }
  labels[unlabeled]<-apply(res,FUN=which.max,MARGIN = 1)
  return(list(class=labels,res=res,error=error, iteration=iteration))
}

#' Assign distance from origin to vertices
#'
#' \code{assign_distance} assigns distance from origin to each vertex described by a similarity matrix. This is achieved via random walk simulation.
#'  Probability of transitioning from one node to another is determined by their similarity. A \code{distance} value is computed as the average number
#'  of nodes on a walk from the origin to each particular vertex. Consequently, this value can be considered the pseudotime value at which the vertex was
#'  reached on a walk from the origin.
#'
#' The function involves solving a system of linear equations, involving matrix A: similarity matrix without origin vertex/vertices. If dimension of
#'  \code{A} exceeds a set threshold \code{big}, we solve the system numerically via conjugate gradient
#'  method for symmetric \code{A} or biconjugate gradient stabilised method for non-symmetric \code{A}.
#'  If we solve numerically, we set a maximum number of iterations (\code{nb_it}). If \code{A} is symmetric, we may provide an initial guess vector for
#'  \code{x} (\code{iguess}), otherwise initial guess defaults to vector of zeroes. Moreover, for numerical solutions error tolerance can be set manually (\code{eps}).
#'
#' @param A a similarity matrix (\code{sparseMatrix} object, as generated by \code{knn.adj2spadjsim} or related function).
#' @param weights matrix of weights (\code{sparseMatrix} object, as generated by \code{knn.adj2spadj} or related function).
#' @param origin index of the origin vertex.
#' @param big maximum number of non-origin vertices for exact solution of linear system. Defaults to \code{1000}.
#' @param nb_it maximum number of iterations for conjugate gradient or biconjugate gradient stabilised method. Defaults to \code{1500}.
#' @param eps error tolerance for conjugate gradient or biconjugate gradient stabilised method. Defaults to \code{1E-6}.
#' @param sym Boolean, is \code{A} symmetric?
#' @param iguess initial guess vector for solution of linear system for conjugate gradient or biconjugate gradient stabilised method.
#' @param method character, if sym==TRUE, the options are "cg" and "minres". biCGSTAB is used otherwise
#' @param target (optional) index/indices of events with prescribed values
#' @param target_values (obligatory if !is.null(target)), numeric - prescribed values for target events
#'
#' @return
#' \code{assign_distance} returns a list containing the following elements.
#'
#' \code{res} is a vector of distance values assigned to each vertex
#'  (indexed by vertex indices).
#'
#' \code{nb_it} is number of iterations needed for numerical solution of linear system. If solution is exact, this is the string \code{exact}.
#'
#' \code{error} value is relevant to numerical solution, otherwise is the string \code{exact}.
#'
#' @export
assign_distance <- function (A, origin, big = 1000, nb_it = 1500, eps = 1e-06, sym = FALSE,
          iguess = NULL, weights = NULL, method = "cg", target = NULL,target_values=NULL)
{
  N <- dim(A)[1]
  .DD <- Matrix::rowSums(A)
  D <- Matrix::Diagonal(x = .DD)
  Dm <- Matrix::Diagonal(x = (.DD)^(-1/2))
  L <- Dm %*% (D - A) %*% Dm
  rm(D)
  adval<-as(rep(0,nrow(L)),"sparseMatrix")

  if (!is.null(target)){
    if (length(target)>1)
      adval<-as(Matrix::rowSums(L[,target]*target_values),"sparseMatrix")
    else
      adval<-as(L[,target]*target_values,"sparseMatrix")
  }


  unlabeled <- which(!(1:nrow(L) %in% c(origin,target)))
  L <- L[unlabeled, unlabeled]
  adval<-adval[unlabeled,]

  if (is.null(weights)) {
    B <- matrix(.DD[unlabeled]^(1/2), nrow = length(unlabeled))
  }
  else {
    B <- Matrix::rowSums((Matrix::Diagonal(x = (.DD)^(-1/2)) %*%
                            A) * weights)
    B <- matrix(B[unlabeled], nrow = length(unlabeled))
  }
  if (!is.null(target)) {

    B<-B-adval
  }

  rm(A)
  if (sym)
    if (is.null(iguess))
      iguess <- rep(0, N)
  else iguess <- .DD^(1/2) * iguess
  if (length(unlabeled) > big) {
    message("iterative")
    if (class(L) != "dgCMatrix")
      stop("use dgCMatrix for big data!")
    if (!sym)
      res <- bicgSparse(L, B, nb_it, eps)
    else if (method == "cg") {
      res <- cgSparse(L, B, iguess[unlabeled], nb_it, eps)
      print(dim(L))
      print(dim(B))
      print(length(iguess[unlabeled]))
    }
    else if (method == "minres")
      res <- minres(L, B, nb_it, eps)
    else stop("method not implemented")
  }
  else {
    print("solve")
    res <- list()
    res$x <- Matrix::solve(L, B)[, 1]
    res$nb_it <- "exact"
    res$error <- "exact"
  }
  out <- matrix(NA, nrow = N)
  out[origin, ] <- 0
  out[unlabeled, ] <- res$x
  out[target,]<-target_values
  out <- as.vector(Dm %*% out)
  return(list(res = out, nb_it = res$nb_it, error = res$error))
}
